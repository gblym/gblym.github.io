---
layout: post
title: 调度场算法（Shunting-yard Algorithm）（下篇）
abstract: 调度场算法是一种用于解析中缀表达式的算法——处理`1+2*3`这种形式的输入，它可以用于输出后缀表达式或生成代码树（抽象代码树，AST）。
tags: Algorithm Parser
---

[中篇](/2014/03/03/shunting-yard-algorithm-2.html)中，我们看到了两种简单的中缀表达式处理方法，但是它们或多或少存在缺点——第一种需要反复地扫描表达式，而第二种难以处理有大量不同优先级的状况；并且，它们都没有考虑到结合性的问题。

于是当年，在那遥远的<del>河南</del>荷兰，正在为实现ALGOL 60而忙碌的[Dijkstra大神](http://en.wikipedia.org/wiki/Edsger_Dijkstra)再也忍不住了。终于，他提出了调度场算法。

调度场算法
---

我们回到[上篇](/2014/02/27/shunting-yard-algorithm.html)，再次梳理一下问题。

这里只讨论关键的处理优先级、结合方向的部分，一个理想的算法应该能做到：

* 能处理优先级。
* 允许同一优先级的运算符从左向右或从右向左结合。
* 处理的耗时、内存占用（即时间、空间复杂度）与表达式长度趋向于正比。
* 可以接受较多的优先级、运算符个数，而复杂度不会显著增加。

另外，我们可以再加上两条：

* 尽可能只扫描表达式一遍。
* 允许在解析时，适度地动态添加运算符和规则。

好，继续观察例子：

`1+(2+3)*4+5`

首先需要注意，调度场算法是一种**从左向右**处理表达式、**自底向上**产生AST的算法。

考虑到AST中数字就是各个叶节点（最末端的节点），并且没有任何顺序变化，我们可以随时按需取用。因此，建立一个堆栈，遇到数字就直接放入。

`输入：+(2+3)*4+5 数字堆栈：1`

接下来，我们回想一下之前说到的朴素的算法，可以发现，优先级较低的运算符可能需要较晚地被处理：

* 在第一种算法中，第二轮扫描中才能处理乘法，第三轮扫描中才能处理加法。
* 第二种算法在处理过程中虽然不涉及顺序，但是在之后的计算中，优先级越低的运算符周围的括号越多，它们的执行被放在了递归外层，因此较晚。

调度场算法给出的解法是，建立一个堆栈，先行存储暂时还不需要处理的运算符：

`输入：(2+3)*4+5 数字堆栈：1 符号堆栈：+`

> 题外话，这个符号堆栈就是所谓的“调度场”。
>
> “调度场”，是一个来自铁路的术语，又叫“编组站”。作为一个外行的我的理解下，调度场是一种主要用于货运调度、兼可以负责各种技术向的任务（比如维修）的车站。

左括号先压着，以等待右括号的到来：

`输入：2+3)*4+5 数字堆栈：1 符号堆栈：+ (`

继续：

`输入：+3)*4+5 数字堆栈：1 2 符号堆栈：+ (`

`输入：3)*4+5 数字堆栈：1 2 符号堆栈：+ ( +`

`输入：)*4+5 数字堆栈：1 2 3 符号堆栈：+ ( +`

好，看到右括号了。它会把左括号之后的一切弹出：

`输入：*4+5 数字堆栈：1 2 3 符号堆栈：+ 弹出：+`

括号对的使命结束，弹出的是一个加号。

对于双目符号的弹出操作，我们首先从数字堆栈取出两个数，执行计算，放回一个数：

`输入：*4+5 数字堆栈：1 5 符号堆栈：+`

继续，看到乘号。此时，符号堆栈顶端是一个加号，加号优先级较低，我们直接压入乘号：

`输入：4+5 数字堆栈：1 5 符号堆栈：+ *`

压入数字：

`输入：+5 数字堆栈：1 5 4 符号堆栈：+ *`

然后，调度场算法的关键步骤来了——下一个是加号——加号比乘号的优先级低，因此弹出乘号：

`输入：5 数字堆栈：1 5 4 符号堆栈：+ 弹出：* 待压入：+`

加号和堆栈内的加号具有相同的优先级，因此弹出堆栈内的加号：

`输入：5 数字堆栈：1 20 弹出：+ 待压入：+`

`输入：5 数字堆栈：21 弹出：+ 待压入：+`

现在可以压入了：

`输入：5 数字堆栈：21 符号堆栈：+`

之后，输入5，输入结束：

`数字堆栈：21 5 符号堆栈：+`

我们弹出符号堆栈中的符号：

`数字堆栈：26`

于是得到结果。

可以发现，如果在上面的过程中不执行计算，直接将数字和出栈的符号依次输出，我们就会得到后缀表达式；而如果计算时不是进行数学运算，而是生成一个二叉树节点，以符号为父节点，取出两个数字堆栈的成员为子节点并压回数字堆栈，我们就会得到AST。

我们可以体会到，调度场算法的核心就在于用堆栈暂存符号以备“调度”，比较新符号和栈顶原有的符号，选择其中更容易结合的（根据优先级、结合方向）出栈——更容易结合就意味着更早地参与计算。理解这点以后，调度场算法就仿佛显而易见、理所当然地存在了。

OPParser中出现的变种
---

[OPParser](https://github.com/hczhcz/opparser)中，我原本打算直接使用调度场算法。但是考虑到语法中一些复杂细节的处理，为了方便编写代码，对调度场算法做了一些改变。

改变的关键点在于：

* 数字、括号，其实可以看作运算符，只是数字出栈比所有运算符更优先。
* 运算符向左、向右的优先级可以不同。

在[头文件](https://github.com/hczhcz/opparser/blob/master/opcalcrule.hpp)中，定义了如下的优先级：

{% highlight c++ linenos %}
const Level levelConst = 4095;
const Level levelAcceptAll = 0;
const Level levelFlushAll = 1;
const Level levelAddSubL = 255;
const Level levelAddSubR = 256;
const Level levelMulDivL = 511;
const Level levelMulDivR = 512;
const Level levelIMulL = 639;
const Level levelIMulR = 640;
const Level levelPwrL = 769;
const Level levelPwrR = 768;
const Level levelFacL = 1023;
const Level levelFuncR = 1280;
{% endhighlight %}

左括号左侧、右括号右侧，使用与数字相同的优先级；左括号右侧和表达式开头（栈底）的优先级最低，表达式右侧和表达式结尾的优先级仅高于前者。

参照着这些定义，我们可以对表达式进行标注：

{% highlight python linenos %}
1+(2+3)*4+5

begin[0]
    [4095]1[4095] [255]+[256] [4095]([0]
        [4095]2[4095] [255]+[256] [4095]3[4095]
    [1])[4095] [511]*[512] [4095]4[4095] [255]+[256] [4095]5[4095]
[1]end
{% endhighlight %}

这样，我们就可以用同一套规则处理数字、运算符和括号了。

然后，从左到右压栈，比较栈顶符号的右侧优先级和新符号的左侧优先级，弹出较高的符号……不必多说，直接单步运行一遍吧：

{% highlight python linenos %}
begin[0] [4095]1[4095] [255]+[256] ...
  Stack ^ Input

begin[0] [4095]1[4095] [255]+[256] [4095]([0] ...
                Stack ^ Input

begin[0] [***********] [255]+[256] [4095]([0] ...
  Stack ^ Input  Output: 1

begin[0] [255]+[256] [4095]([0] ...
  Stack ^ Input  Output: 1

begin[0] [255]+[256] [4095]([0] [4095]2[4095] ...
              Stack ^ Input  Output: 1

begin[0] [255]+[256] [4095]([0] [4095]2[4095] [255]+[256] ...
                         Stack ^ Input  Output: 1

begin[0] [255]+[256] [4095]([0] [4095]2[4095] [255]+[256] [4095]3[4095] ...
                                       Stack ^ Input  Output: 1

begin[0] [255]+[256] [4095]([0] [***********] [255]+[256] [4095]3[4095] ...
                         Stack ^ Input  Output: 1 2

begin[0] [255]+[256] [4095]([0] [255]+[256] [4095]3[4095] ...
                         Stack ^ Input  Output: 1 2

begin[0] [255]+[256] [4095]([0] [255]+[256] [4095]3[4095] [1])[4095] ...
                                     Stack ^ Input  Output: 1 2

begin[0] [255]+[256] [4095]([0] [255]+[256] [4095]3[4095] [1])[4095] [511]*[512] ...
                                                   Stack ^ Input  Output: 1 2

begin[0] [255]+[256] [4095]([0] [255]+[256] [***********] [1])[4095] [511]*[512] ...
                                     Stack ^ Input  Output: 1 2 3

begin[0] [255]+[256] [4095]([0] [*********] [1])[4095] [511]*[512] ...
                         Stack ^ Input  Output: 1 2 3 +

begin[0] [255]+[256] [4095]([0] [1])[4095] [511]*[512] ...
                         Stack ^ Input  Output: 1 5

begin[0] [255]+[256] [*******************] [511]*[512] [4095]4[4095] ...
                                    Stack ^ Input  Output: 1 5

begin[0] [255]+[256] [511]*[512] [4095]4[4095] [255]+[256] [4095]5[4095] [1]end
              Stack ^ Input  Output: 1 5

begin[0] [255]+[256] [511]*[512] [4095]4[4095] [255]+[256] [4095]5[4095] [1]end
                          Stack ^ Input  Output: 1 5

begin[0] [255]+[256] [511]*[512] [4095]4[4095] [255]+[256] [4095]5[4095] [1]end
                                        Stack ^ Input  Output: 1 5

begin[0] [255]+[256] [511]*[512] [***********] [255]+[256] [4095]5[4095] [1]end
                          Stack ^ Input  Output: 1 5 4

begin[0] [255]+[256] [*********] [255]+[256] [4095]5[4095] [1]end
              Stack ^ Input  Output: 1 5 4 *

begin[0] [255]+[256] [255]+[256] [4095]5[4095] [1]end
              Stack ^ Input  Output: 1 20

begin[0] [*********] [255]+[256] [4095]5[4095] [1]end
  Stack ^ Input  Output: 1 20 +

begin[0] [255]+[256] [4095]5[4095] [1]end
  Stack ^ Input  Output: 21

begin[0] [255]+[256] [4095]5[4095] [1]end
              Stack ^ Input  Output: 21

begin[0] [255]+[256] [4095]5[4095] [1]end
                            Stack ^ Input  Output: 21

begin[0] [255]+[256] [***********] [1]end
              Stack ^ Input  Output: 21 5

begin[0] [*********] [1]end
  Stack ^ Input  Output: 21 5 +

begin[0] [1]end
  Stack ^ Input  Output: 26
{% endhighlight %}

最后得到答案。

补充一点，括号还有一种更简单的处理方式——我们设一个变量x，每遇到一个左括号就将它加上一个大数，遇到右括号则减去那个大数，然后对每个符号的左、右优先级，分别加上x即可。

经过上中下三篇至此，本文终于接近尾声了。

我们应当能体会到，调度场算法的解析能力有一定的局限性。现在常见的编程语言通常具有更复杂的语法，因此通常会使用由以[Yacc](http://en.wikipedia.org/wiki/Yacc)为代表的“编译器的编译器”自动生成的[LR Parser](http://en.wikipedia.org/wiki/LR_parser)。不过，调度场算法易于理解，也很适合手工编写，不失为一个<del>居家旅行杀人灭口</del>学习编程的好工具。
